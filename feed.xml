<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zhnzhang.github.io/</id><title>Chirpy</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2022-07-27T13:42:10+00:00</updated> <author> <name>Zhen Zhang</name> <uri>https://zhnzhang.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://zhnzhang.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://zhnzhang.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Zhen Zhang </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>利用Python抽取DOCX文件中的Comments及其对应的References</title><link href="https://zhnzhang.github.io/posts/%E5%88%A9%E7%94%A8python%E6%8A%BD%E5%8F%96docx%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84comments%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84references/" rel="alternate" type="text/html" title="利用Python抽取DOCX文件中的Comments及其对应的References" /><published>2022-07-27T13:37:00+00:00</published> <updated>2022-07-27T13:37:00+00:00</updated> <id>https://zhnzhang.github.io/posts/%E5%88%A9%E7%94%A8python%E6%8A%BD%E5%8F%96docx%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84comments%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84references/</id> <content src="https://zhnzhang.github.io/posts/%E5%88%A9%E7%94%A8python%E6%8A%BD%E5%8F%96docx%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84comments%E5%8F%8A%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84references/" /> <author> <name>{"name"=>"Zhen Zhang", "link"=>"https://github.com/zhnzhang"}</name> </author> <category term="Blogging" /> <category term="Solutions" /> <summary> docx格式是基于XML的压缩文件格式，在MicroSoft Office 2007之后的版本中使用。下面我来讲讲如何利用Python抽取docx文件中的批注以及其所对应的原文部分。（注：后文我将批注称作comment，将批注所对应的原文部分称为reference） 目前网络上已经有博文讲到如何使用Python获取docx文档里的批注，比如： https://blog.csdn.net/qq_43479622/article/details/90580630 另外还有使用宏的方法来获取docx文档里批注的，但目前还没看到有博文讲到连同reference一起抽取的，python-docx的仓库里也有人提了issue。 使用到的Package： python-docx lxml zipfile impor... </summary> </entry> <entry><title>LeetCode 233. 数字 1 的个数</title><link href="https://zhnzhang.github.io/posts/leetcode-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/" rel="alternate" type="text/html" title="LeetCode 233. 数字 1 的个数" /><published>2022-05-03T05:11:00+00:00</published> <updated>2022-05-03T05:11:00+00:00</updated> <id>https://zhnzhang.github.io/posts/leetcode-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/</id> <content src="https://zhnzhang.github.io/posts/leetcode-233-%E6%95%B0%E5%AD%97-1-%E7%9A%84%E4%B8%AA%E6%95%B0/" /> <author> <name>{"name"=>"Zhen Zhang", "link"=>"https://github.com/zhnzhang"}</name> </author> <category term="Blogging" /> <category term="题解" /> <summary> 同剑指 Offer 43. 1～n 整数中 1 出现的次数 计数问题 枚举每一个数位，分情况讨论该位为1时共有多少种情况 时间复杂度：十进制的数n，会有log~10~n位，枚举每一位时，需要遍历所有数位，故时间复杂度为O(log^2^n) 举例说明枚举一个数位时，该如何分情况进行讨论： 假设n为abcdefg，当前枚举到d，我们希望得知d为1的情况可以有多少种。 如果d数位上的值为0，那么d为1的情况有abc * 1000种，因为d的左边可以取0～abc-1，右边可以取0～999 如果d数位上的值为1，那么d为1的情况有abc * 1000 + efg + 1种： 首先当d的左边取0～abc-1，右边取0～999时，所组成的数字不会大于n，故这些... </summary> </entry> <entry><title>LeetCode 239. 滑动窗口最大值</title><link href="https://zhnzhang.github.io/posts/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" rel="alternate" type="text/html" title="LeetCode 239. 滑动窗口最大值" /><published>2022-04-27T10:56:00+00:00</published> <updated>2022-04-27T10:56:00+00:00</updated> <id>https://zhnzhang.github.io/posts/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</id> <content src="https://zhnzhang.github.io/posts/leetcode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/" /> <author> <name>{"name"=>"Zhen Zhang", "link"=>"https://github.com/zhnzhang"}</name> </author> <category term="Blogging" /> <category term="题解" /> <summary> 同剑指 Offer 59 - I. 滑动窗口的最大值 考点：利用单调队列将时间复杂度优化到线性。 这道题并不是一开始就能直接想到用单调队列的，首先从暴力做法入手： 窗口需要满足先入先出的特性，所以这里用双端队列来实现窗口，窗口最左边是队首，最右边是队尾。至于为什么是双端，后文会提到。 在窗口满了后，每次移动都遍历窗口一次，求的最大值。假设所有元素数量为n，窗口长度为k。共需要遍历n - k + 1次，每次遍历时间复杂度O(k)，总的时间复杂度为O(nk)。 如果想要达到线性的时间复杂度，那么可优化的点在哪里呢？我们把目光放到每次求窗口内最大值，都要遍历一遍上面： 由题意，窗口内越靠左的元素，在窗口内的资历越老，越先出队。如果窗口内靠左的元素小于等于窗口内靠右的元素，那么靠左的元素永远也不可能成为我们所求的答案，因为: 只要该... </summary> </entry> <entry><title>LeetCode 426. 将二叉搜索树转化为排序的双向链表</title><link href="https://zhnzhang.github.io/posts/leetcode-426-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" rel="alternate" type="text/html" title="LeetCode 426. 将二叉搜索树转化为排序的双向链表" /><published>2022-04-02T14:30:00+00:00</published> <updated>2022-04-03T02:57:36+00:00</updated> <id>https://zhnzhang.github.io/posts/leetcode-426-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</id> <content src="https://zhnzhang.github.io/posts/leetcode-426-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" /> <author> <name>{"name"=>"Zhen Zhang", "link"=>"https://github.com/zhnzhang"}</name> </author> <category term="Blogging" /> <category term="题解" /> <summary> 同剑指 Offer 36. 二叉搜索树与双向链表 由于要求不能创建任何新的节点，只能调整树中节点指针的指向。 二叉搜索树的中序遍历是升序的序列，所以就选择在中序遍历的过程中，调整节点的指针指向，其中： pre指针保存的是当前节点中序遍历的前一个节点地址 访问当前节点时，它的左子树肯定被访问过了，所以当前节点的left指针可以改 pre指向的节点所对应的数一定是小于当前节点的，所以pre的左右子树肯定被访问过了，故pre的right指针也可以直接改 由于是双向循环链表，所以最后需要再将头节点和尾节点相连。 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; ... </summary> </entry> <entry><title>LeetCode 146. LRU缓存</title><link href="https://zhnzhang.github.io/posts/leetcode-146-lru%E7%BC%93%E5%AD%98/" rel="alternate" type="text/html" title="LeetCode 146. LRU缓存" /><published>2022-03-27T14:48:00+00:00</published> <updated>2022-04-03T02:57:36+00:00</updated> <id>https://zhnzhang.github.io/posts/leetcode-146-lru%E7%BC%93%E5%AD%98/</id> <content src="https://zhnzhang.github.io/posts/leetcode-146-lru%E7%BC%93%E5%AD%98/" /> <author> <name>{"name"=>"Zhen Zhang", "link"=>"https://github.com/zhnzhang"}</name> </author> <category term="Blogging" /> <category term="题解" /> <summary> 这道题要实现LRU缓存机制，包括get和put方法，实际上是要还原这样一个场景：我们有一个缓存，它有固定的大小限制，假设为n。我们需要不断地向其中写入kv键值对，每个键值对占用一个位置。当缓存满了的时候，我们如果再想写入时，需要删掉一个键值对腾出空间。那么我们应该按照什么规则，删除哪个键值对呢？我们就按照LRU的机制来删除。 通俗点说LRU机制就是，我们会对每个键值对记录，最近一次用（get，put(插入或修改)）它的时间是什么，给它一个时间戳。需要删除时，我们会根据时间戳把最早的没有被用过的键值对删去。 我们需要设计一套存储方式，以便在O(1)的时间复杂度内完成get，put操作。 其中我们使用哈希表维护缓存本身的kv键值对，因为哈希表增删改查都是O(1)的。为了实现LRU机制，我们需要在put的时候，能够修改kv对的时间戳，同时我们要能在O(1)的时间复杂度知道哪个kv对相应... </summary> </entry> </feed>
