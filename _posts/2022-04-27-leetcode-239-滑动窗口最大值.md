---
layout: post
title: LeetCode 239. 滑动窗口最大值
author:
  name: Zhen Zhang
  link: https://github.com/zhnzhang
categories:
- Blogging
- 题解
tags:
- leetcode
date: 2022-04-27 18:56 +0800
---
- 同[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
- 考点：利用单调队列将时间复杂度优化到线性。

这道题并不是一开始就能直接想到用单调队列的，首先从暴力做法入手：

- 窗口需要满足先入先出的特性，所以这里用双端队列来实现窗口，窗口最左边是队首，最右边是队尾。至于为什么是双端，后文会提到。
- 在窗口满了后，每次移动都遍历窗口一次，求的最大值。假设所有元素数量为n，窗口长度为k。共需要遍历n - k + 1次，每次遍历时间复杂度O(k)，总的时间复杂度为O(nk)。

如果想要达到线性的时间复杂度，那么可优化的点在哪里呢？我们把目光放到每次求窗口内最大值，都要遍历一遍上面：

- 由题意，窗口内越靠左的元素，在窗口内的资历越老，越先出队。如果窗口内靠左的元素小于等于窗口内靠右的元素，那么靠左的元素永远也不可能成为我们所求的答案，因为:
  - 只要该靠左的元素在窗口内存在，那么靠右的元素必存在，甚至是更晚出队。
  - 而且靠右的元素值比靠左的元素大，故该靠左的元素在剩余的生命周期内永无出头之日，输出到答案中时永远也不会考虑它。
  - 在这种情况下，该靠左的元素没有存在在窗口中的意义，把它删去即可。

- 在对窗口内部元素做了如上优化后，我们发现，队列中从队头到队尾呈现单调下降的趋势，这是一个单调队列。求解窗口内最大值只要返回队列中的队首元素即可，这样就将遍历过程的O(k)优化为了O(1)，总的时间复杂度为O(n)。
- 为了始终将窗口维护为一个单调队列，我们每次在从队尾插入新元素的时候，都从队尾开始，将所有小于等于新插入元素的数删除，然后再插入新的元素。
- 细节：
  - 为什么使用双端队列：
    - 因为上面的优化过程需要队列支持一端删除，另一段插入+删除，所以需要使用双端队列。
  - 为什么队列存储的是下标：
    - 因为需要判断队头元素是否已经滑出窗口，这一步需要使用下标。
  - 代码中for循环中有while循环，为什么总的时间复杂度仍是O(n)：
    - 每个元素只会进队一次出队一次，while循环是作出队操作的，对每个元素也就执行1次。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;		// 队列中存的是下标
        vector<int> res;
        for (int i = 0; i < nums.size(); i ++ ) {	// i为队列右端点下标
            if (q.size() && i - k + 1 > q.front()) q.pop_front();	// 因窗口右滑导致最左元素滑出窗口
            while (q.size() && nums[i] >= nums[q.back()]) q.pop_back();		// 维护单调队列，从队尾开始，小于等于新元素的元素都删除
            q.push_back(i);		// 加入队列
            if (i >= k - 1) res.push_back(nums[q.front()]); // 所维护的单调队列的队首始终是窗口内最大值
        }
        return res;
    }
};
```

尾注：参考yxc剑指offer讲解
